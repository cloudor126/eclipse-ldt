<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="stylesheet.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="bit32.html">bit32</a></li>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="debug.html">debug</a></li>
					<li><a href="global.html">global</a></li>
					<li><a href="io.html">io</a></li>
					<li><a href="math.html">math</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="package.html">package</a></li>
					<li>string</li>
					<li><a href="table.html">table</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>string</code></h1>
   
<p>String Manipulation.</p>

   
<p>This library provides generic functions for string manipulation,
such as finding and extracting substrings, and pattern matching.
When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). 
Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string.
Thus, the last character is at position -1, and so on.</p>

<p>The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style.
For instance, string.byte(s, i) can be written as s:byte(i).</p>

<p>The string library assumes one-byte character encodings.</p>

	<h2><a id="#(string)" >Type <code>string</code></a></h2>
		<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).byte">string.byte(s, i, j)</a></td>
		<td class="summary">
<p>Returns the internal numerical codes of the characters <code>s[i], s[i+1], ..., s[j]</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).char">string.char(...)</a></td>
		<td class="summary">
<p>Receives zero or more integers.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).dump">string.dump(f)</a></td>
		<td class="summary">
<p>Returns a string containing a binary representation of the given function,
so that a later <code>load</code> on this string returns a copy of the function (but with new upvalues). </p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).find">string.find(s, pattern, init, plain)</a></td>
		<td class="summary">
<p>Looks for the first match of <code>pattern</code> in the string <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).format">string.format(formatstring, ...)</a></td>
		<td class="summary">
<p>Returns a formatted version of its variable number of arguments following the description given
in its first argument (which must be a string).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).gmatch">string.gmatch(s, pattern)</a></td>
		<td class="summary">
<p>Returns an iterator function that, each time it is called, returns the
next captures from <code>pattern</code> over string <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).gsub">string.gsub(s, pattern, repl, n)</a></td>
		<td class="summary">
<p>Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given) occurrences of 
the pattern have been replaced by a replacement string specified by <code>repl</code>, 
which can be a string, a table, or a function.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).len">string.len(s)</a></td>
		<td class="summary">
<p>Receives a string and returns its length.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).lower">string.lower(s)</a></td>
		<td class="summary">
<p>Receives a string and returns a copy of this string with all uppercase
letters changed to lowercase.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).match">string.match(s, pattern, init)</a></td>
		<td class="summary">
<p>Looks for the first <em>match</em> of <code>pattern</code> in the string <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).rep">string.rep(s, n)</a></td>
		<td class="summary">
<p>Returns a string that is the concatenation of <code>n</code> copies of the string <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).reverse">string.reverse(s)</a></td>
		<td class="summary">
<p>Returns a string that is the string <code>s</code> reversed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).sub">string.sub(s, i, j)</a></td>
		<td class="summary">
<p>Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
<code>j</code>; <code>i</code> and <code>j</code> can be negative.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).upper">string.upper(s)</a></td>
		<td class="summary">
<p>Receives a string and returns a copy of this string with all lowercase
letters changed to uppercase.</p>
</td>
		</tr>
	</table>

	<h2><a id="#(string)" >Type <code>string</code></a></h2>
		<h3>Field(s)</h3>
		<dl class="function">
<dt>
<a id="#(string).byte" >
<strong>string.byte(s, i, j)</strong>
</a>
</dt>
<dd>
	
<p>Returns the internal numerical codes of the characters <code>s[i], s[i+1], ..., s[j]</code>.</p>

	
<p>The default value
for i is 1; the default value for j is i. These indices are corrected following the same rules of
function <code>string.sub</code>.</p>

<p>Numerical codes are not necessarily portable across platforms.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#number i </em></code>: 
start index, default value is 1.</p>

				</li>
				<li>
				
<p><code><em>#number j </em></code>: 
end index, default value is <code>i</code>.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,..., <code>s[j]</code></p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).char" >
<strong>string.char(...)</strong>
</a>
</dt>
<dd>
	
<p>Receives zero or more integers.</p>

	
<p>Returns a string with length equal to
the number of arguments, in which each character has the internal numerical
code equal to its corresponding argument.</p>

<p>Note that numerical codes are not necessarily portable across platforms.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> ... </em></code>: 
zero or more integers.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a string with length equal to
the number of arguments, in which each character has the internal numerical
code equal to its corresponding argument.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).dump" >
<strong>string.dump(f)</strong>
</a>
</dt>
<dd>
	
<p>Returns a string containing a binary representation of the given function,
so that a later <code>load</code> on this string returns a copy of the function (but with new upvalues). </p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> f </em></code>: 
the function to dump.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a string representation of the given function.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).find" >
<strong>string.find(s, pattern, init, plain)</strong>
</a>
</dt>
<dd>
	
<p>Looks for the first match of <code>pattern</code> in the string <code>s</code>.</p>

	
<p>If it finds a
match, then <code>find</code> returns the indices of <code>s</code> where this occurrence starts
and ends; otherwise, it returns <strong>nil</strong>. A third, optional numerical argument
<code>init</code> specifies where to start the search; its default value is 1 and
can be negative. A value of <strong>true</strong> as a fourth, optional argument <code>plain</code>
turns off the pattern matching facilities, so the function does a plain
"find substring" operation, with no characters in <code>pattern</code> being considered
"magic". Note that if plain is given, then init must be given as well. </p>

<p>If the pattern has captures, then in a successful match the captured values
are also returned, after the two indices. </p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em>#number init </em></code>: 
index where to start the search. (default value is 1)</p>

				</li>
				<li>
				
<p><code><em>#boolean plain </em></code>: 
set to true to search without pattern matching. (default value is false)</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number, #number:</em>
start and end indices of first occurrence.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
if pattern not found.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).format" >
<strong>string.format(formatstring, ...)</strong>
</a>
</dt>
<dd>
	
<p>Returns a formatted version of its variable number of arguments following the description given
in its first argument (which must be a string).</p>

	
<p>The format string follows the same rules as the
ANSI C function <code>sprintf</code>. The only differences are that the options/modifiers <code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>, and
<code>p</code> are not supported and that there is an extra option, <code>q</code>. The <code>q</code> option formats a string between
double quotes, using escape sequences when necessary to ensure that it can safely be read back
by the Lua interpreter. For instance, the call </p>

<pre><code>string.format('%q', 'a string with "quotes" and \n new line')
</code></pre>

<p>will produce the string:</p>

<pre><code>"a string with \"quotes\" and \
    new line"
</code></pre>

<p>Options <code>A</code> and <code>a</code> (when available), <code>E</code>, <code>e</code>, <code>f</code>, <code>G</code>, and <code>g</code> all expect a number as argument.
Options <code>c</code>, <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code> also expect a number, but the range of that number
may be limited by the underlying C implementation. For options <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>, the number cannot
be negative. Option <code>q</code> expects a string; option <code>s</code> expects a string without embedded zeros.
If the argument to option <code>s</code> is not a string, it is converted to one following the same rules of <code>tostring</code>. </p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string formatstring </em></code>: 
the string template. </p>

				</li>
				<li>
				
<p><code><em> ... </em></code>: 
arguments could be strings or numbers.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the formatted string.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).gmatch" >
<strong>string.gmatch(s, pattern)</strong>
</a>
</dt>
<dd>
	
<p>Returns an iterator function that, each time it is called, returns the
next captures from <code>pattern</code> over string <code>s</code>.</p>

	
<p>If <code>pattern</code> specifies no
captures, then the whole match is produced in each call.
 As an example, the following loop will iterate over all the words from string s, printing one per line:</p>

<pre><code>s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
  print(w)
end
</code></pre>

<p>The next example collects all pairs key=value from the given string into a table:</p>

<pre><code>t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
  t[k] = v
end
</code></pre>

<p>For this function, a '<code>^</code>' at the start of a pattern does not work as an
anchor, as this would prevent the iteration.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>Iterator of captures.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).gsub" >
<strong>string.gsub(s, pattern, repl, n)</strong>
</a>
</dt>
<dd>
	
<p>Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given) occurrences of 
the pattern have been replaced by a replacement string specified by <code>repl</code>, 
which can be a string, a table, or a function.</p>

	
<p><code>gsub</code> also returns, as its second 
value, the total number of matches that occurred. The name <code>gsub</code> comes from 
<code>Global SUBstitution</code>. </p>

<p>If <code>repl</code> is a string, then its value is used for replacement. The character
<code>%</code> works as an escape character: any sequence in <code>repl</code> of the form <code>%n</code>,
with <em>n</em> between 1 and 9, stands for the value of the <em>n</em>-th captured
substring (see below). The sequence <code>%0</code> stands for the whole match. The
sequence <code>%%</code> stands for a single <code>%</code>.</p>

<p>If <code>repl</code> is a table, then the table is queried for every match, using the first capture as the key. </p>

<p>If <code>repl</code> is a function, then this function is called every time a match occurs, 
with all captured substrings passed as arguments, in order. </p>

<p>If the value returned by the table query or by the function call is a string or
a number, then it is used as the replacement string; otherwise, if it is <strong>false</strong> or <strong>nil</strong>,
then there is no replacement (that is, the original match is kept in the string). </p>

<p>Here are some examples:</p>

<pre><code>x = string.gsub("hello world", "(%w+)", "%1 %1")
--&gt; x="hello hello world world"

x = string.gsub("hello world", "%w+", "%0 %0", 1)
--&gt; x="hello hello world"

x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
--&gt; x="world hello Lua from"

x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
--&gt; x="home = /home/roberto, user = roberto"

x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
      return loadstring(s)()
    end)
--&gt; x="4+5 = 9"

local t = {name="lua", version="5.1"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
--&gt; x="lua-5.2.tar.gz"
</code></pre>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em> repl </em></code>: 
replacement could be a string, a table or a function.</p>

				</li>
				<li>
				
<p><code><em>#number n </em></code>: 
number of occurences to replace, default is nil which means all occurences. </p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a modified copy of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).len" >
<strong>string.len(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a string and returns its length.</p>

	
<p>The empty string <code>""</code> has
length 0. Embedded zeros are counted, so <code>"a\000bc\000"</code> has length 5.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#number:</em>
the lenght of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).lower" >
<strong>string.lower(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a string and returns a copy of this string with all uppercase
letters changed to lowercase.</p>

	
<p>All other characters are left unchanged. The
definition of what an uppercase letter is depends on the current locale.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a lower case version of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).match" >
<strong>string.match(s, pattern, init)</strong>
</a>
</dt>
<dd>
	
<p>Looks for the first <em>match</em> of <code>pattern</code> in the string <code>s</code>.</p>

	
<p>If it
finds one, then <code>match</code> returns the captures from the pattern; otherwise
it returns <strong>nil</strong>. If <code>pattern</code> specifies no captures, then the whole match
is returned. A third, optional numerical argument <code>init</code> specifies where
to start the search; its default value is 1 and can be negative.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em>#number init </em></code>: 
index where to start the search. (default value is 1)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. </p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).rep" >
<strong>string.rep(s, n)</strong>
</a>
</dt>
<dd>
	
<p>Returns a string that is the concatenation of <code>n</code> copies of the string <code>s</code>.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#number n </em></code>: 
number of repetition.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the concatenation of <code>n</code> copies of the string <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).reverse" >
<strong>string.reverse(s)</strong>
</a>
</dt>
<dd>
	
<p>Returns a string that is the string <code>s</code> reversed.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the string <code>s</code> reversed.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).sub" >
<strong>string.sub(s, i, j)</strong>
</a>
</dt>
<dd>
	
<p>Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
<code>j</code>; <code>i</code> and <code>j</code> can be negative.</p>

	
<p>If <code>j</code> is absent, then it is assumed to
be equal to -1 (which is the same as the string length). In particular,
the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code> with length <code>j</code>, and
<code>string.sub(s, -i)</code> returns a suffix of <code>s</code> with length <code>i</code>.
If, after the translation of negative indices, i is less than 1, it is corrected to 1.</p>

<p>If <code>j</code> is greater than the string length, it is corrected to that length. If, after these
corrections, <code>i</code> is greater than <code>j</code>, the function returns the empty string.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
				<li>
				
<p><code><em>#number i </em></code>: 
start index.</p>

				</li>
				<li>
				
<p><code><em>#number j </em></code>: 
end index. (default value is -1, which is the same as the string lenght)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the substring of <code>s</code> that starts at <code>i</code> and continues until <code>j</code>. </p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).upper" >
<strong>string.upper(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a string and returns a copy of this string with all lowercase
letters changed to uppercase.</p>

	
<p>All other characters are left unchanged. The
definition of what a lowercase letter is depends on the current locale.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
string to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a upper case version of <code>s</code>.</p>


</dd>
</dl>

</div>

</div>
</body>
</html>
